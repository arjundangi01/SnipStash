import { db } from "@/src/lib/db";
import { detectTags, getLanguageTag } from "@/src/lib/auto-tag";

export async function createSnippet(data: {
  title: string;
  code: string;
  language: string;
  description?: string;
  userId: string;
  tags?: string[];
}) {
  try {
    // Auto-detect tags from code
    const autoDetectedTags = detectTags(data.code);

    // Add language as a tag
    const languageTag = getLanguageTag(data.language);
    if (!autoDetectedTags.includes(languageTag)) {
      autoDetectedTags.push(languageTag);
    }

    // Combine auto-detected tags with user-provided tags
    const allTags = [...new Set([...(data.tags || []), ...autoDetectedTags])];

    // Create snippet with tags
    const snippet = await db.snippet.create({
      data: {
        title: data.title,
        code: data.code,
        language: data.language,
        description: data.description,
        userId: data.userId,
      },
    });

    // Create or connect tags
    for (const tagName of allTags) {
      // Find if tag already exists for this user
      const existingTag = await db.tag.findFirst({
        where: {
          name: tagName,
          userId: data.userId,
        },
      });

      if (existingTag) {
        // Connect snippet to existing tag
        await db.snippet.update({
          where: { id: snippet.id },
          data: {
            tags: {
              connect: { id: existingTag.id },
            },
          },
        });
      } else {
        // Create new tag and connect to snippet
        const isAutoGenerated = autoDetectedTags.includes(tagName);
        await db.tag.create({
          data: {
            name: tagName,
            userId: data.userId,
            isAutoGenerated,
            snippets: {
              connect: { id: snippet.id },
            },
          },
        });
      }
    }

    return snippet;
  } catch (error) {
    console.error("Error creating snippet:", error);
    throw error;
  }
}

export async function updateSnippet(
  snippetId: string,
  data: {
    title?: string;
    code?: string;
    language?: string;
    description?: string;
    tags?: string[];
  },
  userId: string
) {
  try {
    // Get existing snippet
    const existingSnippet = await db.snippet.findUnique({
      where: { id: snippetId },
      include: { tags: true },
    });

    if (!existingSnippet || existingSnippet.userId !== userId) {
      throw new Error("Snippet not found or unauthorized");
    }

    // Auto-detect tags if code has changed
    let autoDetectedTags: string[] = [];
    if (data.code) {
      autoDetectedTags = detectTags(data.code);

      // Add language as a tag
      const languageTag = getLanguageTag(
        data.language || existingSnippet.language
      );
      if (!autoDetectedTags.includes(languageTag)) {
        autoDetectedTags.push(languageTag);
      }
    }

    // Combine auto-detected tags with user-provided tags
    const allTags = [...new Set([...(data.tags || []), ...autoDetectedTags])];

    // Disconnect all existing tags
    await db.snippet.update({
      where: { id: snippetId },
      data: {
        tags: {
          disconnect: existingSnippet.tags.map((tag) => ({ id: tag.id })),
        },
      },
    });

    // Update snippet basic data
    const updatedSnippet = await db.snippet.update({
      where: { id: snippetId },
      data: {
        title: data.title,
        code: data.code,
        language: data.language,
        description: data.description,
      },
    });

    // Create or connect tags
    for (const tagName of allTags) {
      // Find if tag already exists for this user
      const existingTag = await db.tag.findFirst({
        where: {
          name: tagName,
          userId: userId,
        },
      });

      if (existingTag) {
        // Connect snippet to existing tag
        await db.snippet.update({
          where: { id: snippetId },
          data: {
            tags: {
              connect: { id: existingTag.id },
            },
          },
        });
      } else {
        // Create new tag and connect to snippet
        const isAutoGenerated = autoDetectedTags.includes(tagName);
        await db.tag.create({
          data: {
            name: tagName,
            userId: userId,
            isAutoGenerated,
            snippets: {
              connect: { id: snippetId },
            },
          },
        });
      }
    }

    return updatedSnippet;
  } catch (error) {
    console.error("Error updating snippet:", error);
    throw error;
  }
}

export async function deleteSnippet(snippetId: string, userId: string) {
  try {
    const snippet = await db.snippet.findUnique({
      where: { id: snippetId },
    });

    if (!snippet || snippet.userId !== userId) {
      throw new Error("Snippet not found or unauthorized");
    }

    // Delete the snippet
    await db.snippet.delete({
      where: { id: snippetId },
    });

    return true;
  } catch (error) {
    console.error("Error deleting snippet:", error);
    throw error;
  }
}

export async function getSnippetById(snippetId: string, userId: string) {
  try {
    const snippet = await db.snippet.findUnique({
      where: { id: snippetId },
      include: { tags: true },
    });

    if (!snippet || snippet.userId !== userId) {
      return null;
    }

    return snippet;
  } catch (error) {
    console.error("Error fetching snippet:", error);
    throw error;
  }
}

export async function getUserSnippets(
  userId: string,
  {
    search = "",
    language = "",
    tag = "",
    page = 1,
    limit = 10,
  }: {
    search?: string;
    language?: string;
    tag?: string;
    page?: number;
    limit?: number;
  }
) {
  try {
    const skip = (page - 1) * limit;

    // Build filter conditions
    const where: any = { userId };

    if (search) {
      where.OR = [
        { title: { contains: search, mode: "insensitive" } },
        { code: { contains: search, mode: "insensitive" } },
        { description: { contains: search, mode: "insensitive" } },
      ];
    }

    if (language) {
      where.language = language;
    }

    if (tag) {
      where.tags = {
        some: {
          name: tag,
        },
      };
    }

    // Get snippets with pagination
    const [snippets, totalCount] = await Promise.all([
      db.snippet.findMany({
        where,
        include: { tags: true },
        orderBy: { createdAt: "desc" },
        skip,
        take: limit,
      }),
      db.snippet.count({ where }),
    ]);

    return {
      snippets,
      pagination: {
        total: totalCount,
        page,
        limit,
        totalPages: Math.ceil(totalCount / limit),
      },
    };
  } catch (error) {
    console.error("Error fetching snippets:", error);
    throw error;
  }
}

export async function getUserTags(userId: string) {
  try {
    const tags = await db.tag.findMany({
      where: { userId },
      include: {
        _count: {
          select: { snippets: true },
        },
      },
    });

    return tags.map((tag) => ({
      id: tag.id,
      name: tag.name,
      count: tag._count.snippets,
      isAutoGenerated: tag.isAutoGenerated,
    }));
  } catch (error) {
    console.error("Error fetching tags:", error);
    throw error;
  }
}

export async function getUserLanguages(userId: string) {
  try {
    const snippets = await db.snippet.findMany({
      where: { userId },
      select: { language: true },
    });

    const languageCounts: Record<string, number> = {};

    snippets.forEach((snippet) => {
      const { language } = snippet;
      languageCounts[language] = (languageCounts[language] || 0) + 1;
    });

    const languages = Object.entries(languageCounts).map(([name, count]) => ({
      name,
      count,
    }));

    return languages.sort((a, b) => b.count - a.count);
  } catch (error) {
    console.error("Error fetching languages:", error);
    throw error;
  }
}
